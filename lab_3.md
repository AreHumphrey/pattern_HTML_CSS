

#  Лабораторная работа  
## **Моделирование многозадачности и обмена данными в C++**


| Понятие | Определение |
|--------|------------------|
| **Поток (thread)** | Отдельная "дорожка" выполнения внутри одной программы. |
| **Таймер / задержка** | Пауза: "подожди 1 секунду" — имитирует работу или ожидание. |
| **Общая переменная** | Через неё потоки "общаются" (аналог IPC). |
| **Мьютекс (mutex)** | "Замок", который не даёт двум потокам одновременно менять данные. |
| **join()** | "Жди, пока поток закончит" — чтобы программа не завершилась раньше времени. |

---

## Основной код программы 


```cpp
// Этот код моделирует многозадачность с помощью потоков.

#include <iostream>      // для вывода текста
#include <thread>        // для создания потоков (многозадачности)
#include <chrono>        // для таймеров (задержек)
#include <mutex>         // для "замка" — защиты от путаницы

// --- ОБЩИЕ ПЕРЕМЕННЫЕ (видны всем функциям) ---
int shared_data = 0;           // через эту переменную потоки взаимодейтсвуют
std::mutex data_lock;          // "замок" — чтобы не было ошибок при записи/чтении

// --- ФУНКЦИЯ: ЗАДАЧА 1 (писатель) ---
void task1() {
    for (int i = 1; i <= 3; i++) {
        //  БЛОКИРУЕМ замок, чтобы никто не мешал
        data_lock.lock();
        shared_data = i * 10;  // записываем новое число
        std::cout << "Задача 1 записала: " << shared_data << std::endl;
        data_lock.unlock();    // ОТКРЫВАЕМ замок

        //  Ждём 1 секунду — это "таймер"
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

// --- ФУНКЦИЯ: ЗАДАЧА 2 (читатель) ---
void task2() {
    for (int i = 1; i <= 3; i++) {
        //  БЛОКИРУЕМ замок перед чтением
        data_lock.lock();
        int value = shared_data; // читаем текущее значение
        std::cout << "          Задача 2 прочитала: " << value << std::endl;
        data_lock.unlock();      // ОТКРЫВАЕМ замок

        // Ждём 1.5 секунды — читает медленнее, чем пишет
        std::this_thread::sleep_for(std::chrono::milliseconds(1500));
    }
}

// --- ФУНКЦИЯ: ЗАДАЧА 3 (наблюдатель) ---
void task3() {
    for (int i = 1; i <= 4; i++) {
        // Защищаем чтение
        data_lock.lock();
        std::cout << "                    [Наблюдатель] Видит: " << shared_data << std::endl;
        data_lock.unlock();

        // Ждёт 800 миллисекунд
        std::this_thread::sleep_for(std::chrono::milliseconds(800));
    }
}

// --- ГЛАВНАЯ ФУНКЦИЯ (старт программы) ---
int main() {
    std::cout << "=== ЗАПУСК ТРЁХ ЗАДАЧ ОДНОВРЕМЕННО ===\n\n";

    // Создаём три потока (три параллельные задачи)
    std::thread t1(task1);  // запускает task1
    std::thread t2(task2);  // запускает task2
    std::thread t3(task3);  // запускает task3

    // Ждём, пока все три задачи завершатся
    t1.join();  // ждать завершения задачи 1
    t2.join();  // ждать завершения задачи 2
    t3.join();  // ждать завершения задачи 3

    std::cout << "\nВсе задачи завершены!\n";
    return 0;
}
```

> **Этот код уже включает всё для Заданий 1–5 и 6–10**  
> Просто следуйте инструкциям ниже.

---

##  Задания 
### Задания необходимо выполнять по порядку

Каждое задание — это **небольшое изменение** в коде.  


---

### Задание 1. Запустите программу "как есть"

1. Нажмите **Run**.  
2. Посмотрите, как три задачи работают **одновременно** 

>  **Сделайте скриншот результата** — он понадобится в отчёте.

---

### Задание 2. Измените таймер в Задаче 1

**Цель**: Ускорить Задачу 1.

1. Найдите строку в `task1`:
   ```cpp
   std::this_thread::sleep_for(std::chrono::seconds(1));
   ```
2. Замените её на:
   ```cpp
   std::this_thread::sleep_for(std::chrono::milliseconds(300)); // ждать 0.3 сек
   ```
3. Нажмите **Run**.

## **Вопрос**:  
> Как изменился вывод? Почему Задача 1 теперь появляется чаще?

---

###  Задание 3. Уберите мьютекс

**Цель**: Увидеть, что будет без защиты.

1. В функции `task1` **удалите** строки:
   ```cpp
   data_lock.lock();
   data_lock.unlock();
   ```
2. В функции `task2` **удалите** строки:
   ```cpp
   data_lock.lock();
   data_lock.unlock();
   ```
3. В функции `task3` **удалите** строки:
   ```cpp
   data_lock.lock();
   data_lock.unlock();
   ```
4. Нажмите **Run** несколько раз.

## **Вопрос**:  
> Иногда текст "рвётся" или появляется мусор. Почему? Что делал "замок"?

---

###  Задание 4. Верните "замок" и измените Задачу 2

**Цель**: Сделать так, чтобы Задача 2 читала **чаще**.

1. Верните все строки с `lock()` и `unlock()` обратно (как в основном коде).  
2. В `task2` замените:
   ```cpp
   std::this_thread::sleep_for(std::chrono::milliseconds(1500));
   ```
   на:
   ```cpp
   std::this_thread::sleep_for(std::chrono::milliseconds(500)); // читает каждые 0.5 сек
   ```
3. Нажмите **Run**.

## **Вопрос**:  
> Теперь Задача 2 часто читает одно и то же число. Почему?

---

###  Задание 5. Измените начальное значение

**Цель**: Понять, откуда берутся данные.

1. Найдите строку в начале программы:
   ```cpp
   int shared_data = 0;
   ```
2. Замените `0` на `999`.  
3. Нажмите **Run**.

**Вопрос**:  
> Что первым видит Задача 2? Почему?

---

###  Задание 6. Сделайте Задачу 3 не появляющейся

**Цель**: Научиться управлять выводом.

1. В функции `task3` **закомментируйте** строку с `cout`:
   ```cpp
   // std::cout << "                    [Наблюдатель] Видит: " << shared_data << std::endl;
   ```
2. Добавьте вместо неё:
   ```cpp
   if (shared_data % 20 == 0) {
       std::cout << "                    [Наблюдатель] Обнаружил круглое число: " << shared_data << std::endl;
   }
   ```
3. Нажмите **Run**.

## **Вопрос**:  
> Когда теперь появляется сообщение от Наблюдателя?

---

###  Задание 7. Добавьте счётчик обращений

**Цель**: Посчитать, сколько раз читали данные.

1. Добавьте **новую переменную** в начало программы (рядом с `shared_data`):
   ```cpp
   int read_count = 0; // сколько раз прочитали данные
   ```
2. Внутри `task2`, **после** `int value = shared_data;`, добавьте:
   ```cpp
   read_count++;
   ```
3. В конце `main()`, **перед** `return 0;`, добавьте:
   ```cpp
   std::cout << "Всего чтений: " << read_count << std::endl;
   ```
4. Нажмите **Run**.

>  **Ошибка?**  
> Если компилятор ругается — добавьте `std::mutex count_lock;` и защищайте `read_count` так же, как `shared_data`.  
> Но для простоты можно **не защищать** — в учебных целях допустимо.

## **Вопрос**:  
> Сколько раз программа прочитала данные? Почему именно столько?

---

###  Задание 8. Сделайте Задачу 1 "одноразовой"

**Цель**: Понять, что потоки могут делать разное количество шагов.

1. В `task1` замените цикл:
   ```cpp
   for (int i = 1; i <= 1; i++) { // только 1 шаг!
   ```
2. Нажмите **Run**.

## **Вопрос**:  
> Что происходит, когда Задача 1 завершается первой? Продолжают ли работать другие?

---

###  Задание 9. Добавьте сообщение о завершении каждой задачи

**Цель**: Увидеть, когда каждая задача заканчивается.

1. В конец `task1` добавьте:
   ```cpp
   std::cout << "Задача 1 ЗАВЕРШЕНА\n";
   ```
2. В конец `task2` добавьте:
   ```cpp
   std::cout << "          Задача 2 ЗАВЕРШЕНА\n";
   ```
3. В конец `task3` добавьте:
   ```cpp
   std::cout << "                    Задача 3 ЗАВЕРШЕНА\n";
   ```
4. Нажмите **Run**.

№№ **Вопрос**:  
> В каком порядке завершаются задачи? Почему?

---

###  Задание 10. Эксперимент: уберите один `join()`

**Цель**: Понять, зачем нужен `join()`.

1. В `main()` **удалите** строку:
   ```cpp
   t3.join();
   ```
2. Нажмите **Run**.

## **Вопрос**:  
> Исчезло ли сообщение от Задачи 3? Почему? Что делает `join()`?

---

##  Отчёт по лабораторной работе

Оформите отчёт в Word или блокноте. Включите:

1. **ФИО, группа**  
2. **Цель работы** (1–2 предложения)  
3. **Скриншот результата из Задания 1**  
4. **Ответы на все 10 вопросов** (по одному предложению на вопрос)  
5. **Вывод** (4–5 предложений):  
   - Что вы поняли о многозадачности?  
   - Зачем нужны таймеры и "замки"?  
   - Как это связано с реальными программами (браузер, игра, мессенджер)?  

---

# Не не все) Давайте дальше на метафорах

## **Моделирование "кухни" с поваром и официантом**

> 💡 **Идея**: Представьте ресторан:  
> - **Повар** готовит блюда (одна задача),  
> - **Официант** приносит их клиенту (вторая задача),  
> - Они общаются через **столик** (общая переменная),  
> - А **таймер** имитирует время готовки и подачи.

Это — наглядная модель **многозадачности и межпоточного взаимодействия**!
---

###  Цель работы
Понять, как разные части программы могут работать одновременно, обмениваться данными и использовать задержки (таймеры) для имитации реального времени.

---


| Что у нас | В программе |
|-------------|-------------|
| Повар | Поток `cook()` |
| Официант | Поток `waiter()` |
| Готовое блюдо на столе | Общая переменная `dish` |
| "Не трогай, пока не готово!" | Мьютекс (`std::mutex`) |
| Время готовки / подачи | `sleep_for()` — таймер |

---

##  Основной код программы

Скопируйте этот код в компилятор:

```cpp
// Программа моделирует работу ресторана с помощью двух потоков.

#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <string>

// Общие данные
std::string dish = "";           // что лежит на столе? (пусто в начале)
bool dish_ready = false;         // готово ли блюдо?
std::mutex kitchen_lock;         // "замок" для кухни — чтобы не было путаницы

// --- ПОВАР: готовит блюда ---
void cook() {
    for (int i = 1; i <= 3; i++) {
        std::cout << "[Повар] Готовлю блюдо #" << i << "...\n";
        
        // Имитация готовки: ждём 2 секунды
        std::this_thread::sleep_for(std::chrono::seconds(2));
        
        // Кладём блюдо на стол
        kitchen_lock.lock();
        dish = "Блюдо #" + std::to_string(i);
        dish_ready = true;
        std::cout << "[Повар] Готово! Положил на стол: " << dish << "\n";
        kitchen_lock.unlock();
        
        // Ждём, пока официант заберёт (имитация)
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}

// --- ОФИЦИАНТ: приносит блюда клиенту ---
void waiter() {
    int served = 0;
    while (served < 3) {
        kitchen_lock.lock();
        if (dish_ready) {
            std::cout << "          [Официант] Забираю со стола: " << dish << "\n";
            dish = "";           // стол пуст
            dish_ready = false;  // блюдо унесено
            served++;
        }
        kitchen_lock.unlock();
        
        // Имитация ходьбы: ждём 1 секунду
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

// --- ОСНОВНАЯ ПРОГРАММА ---
int main() {
    std::cout << "=== РАБОТА РЕСТОРАНА НАЧАЛАСЬ ===\n\n";
    
    // Запускаем повара и официанта одновременно
    std::thread chef(cook);
    std::thread server(waiter);
    
    // Ждём, пока оба закончат
    chef.join();
    server.join();
    
    std::cout << "\n Ресторан закрыт. Всё готово)\n";
    return 0;
}
```

---

## Задания 
### Делайте так же по порядку

Каждое задание — это **одно-два изменения** в коде. После каждого — нажмите **Run**!

---

### Задание 1. Запустите программу "как есть"

>  **Сделайте скриншот результата** — он понадобится в отчёте.

## **Вопрос**:  
> Почему официант иногда "ходит туда-сюда", но ничего не забирает :(?

---

###  Задание 2. Ускорьте повара

**Цель**: Сделать так, чтобы блюда готовились быстрее.

1. В функции `cook()` найдите строку:
   ```cpp
   std::this_thread::sleep_for(std::chrono::seconds(2));
   ```
2. Замените `seconds(2)` на `milliseconds(800)`.  
3. Нажмите **Run**.

## **Вопрос**:  
> Как изменилась работа официанта? Почему он стал "забирать чаще"?

---

### Задание 3. Уберите мьютекс

**Цель**: Увидеть, что будет без защиты общих данных.

1. В функции `cook()` **удалите** строки:
   ```cpp
   kitchen_lock.lock();
   kitchen_lock.unlock();
   ```
2. В функции `waiter()` **удалите** строки:
   ```cpp
   kitchen_lock.lock();
   kitchen_lock.unlock();
   ```
3. Нажмите **Run** несколько раз.

## **Вопрос**:  
> Иногда текст "рвётся" или появляются странные сообщения. Почему? Что защищал "замок"?

---

### Задание 4. Добавьте клиента

**Цель**: Добавить третью роль — клиента, который ест блюда.

1. Добавьте новую функцию **в конец кода** (перед `main`):
   ```cpp
   void client() {
       int eaten = 0;
       while (eaten < 3) {
           // Клиент "ждёт", пока официант принесёт
           std::this_thread::sleep_for(std::chrono::milliseconds(1200));
           std::cout << "                    [Клиент] Ммм! Вкусно!\n";
           eaten++;
       }
   }
   ```
2. В `main()` добавьте:
   ```cpp
   std::thread guest(client);
   ```
3. И в конце `main()` добавьте:
   ```cpp
   guest.join();
   ```
4. Нажмите **Run**.

## **Вопрос**:  
> Как теперь выглядит вывод? Работают ли все трое одновременно?

---

###  Задание 5. Сделайте повара "ленивым"

**Цель**: Повар готовит только 1 блюдо.

1. В функции `cook()` замените:
   ```cpp
   for (int i = 1; i <= 3; i++)
   ```
   на:
   ```cpp
   for (int i = 1; i <= 1; i++)
   ```
2. Нажмите **Run**.

**Вопрос**:  
> Что происходит с официантом и клиентом? Почему программа "зависает"?

> **Подсказка**: Официант ждёт 3 блюда, но повар приготовил только 1)

---

## Отчёт по лабораторной работе

Оформите отчёт в Word. Включите:

1. **ФИО, группа**  
2. **Цель работы** (1–2 предложения)  
3. **Скриншот результата из Задания 1**  
4. **Ответы на 5 вопросов** (по 1–2 предложения)  
5. **Вывод** (4–5 предложений):  
   - Что вы поняли о многозадачности?)
   - Как это похоже на реальные программы (например, загрузка видео + воспроизведение)?  

---

